<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Flash Detector v2.1 - UX Improved (2025-12-02)</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
        }
        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        .slider-track {
            background: linear-gradient(to right, #4f46e5, #7c3aed);
        }
        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #cbd5e1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #7c3aed;
            cursor: pointer;
            border: 2px solid white;
        }
        .result-good { color: #059669; }
        .result-warning { color: #d97706; }
        .result-bad { color: #dc2626; }
        .image-container {
            position: relative;
            background: #f8fafc;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #e2e8f0;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .drop-zone {
            border: 2px dashed #94a3b8;
            transition: all 0.3s ease;
            background: #f8fafc;
        }
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #7c3aed;
            background: rgba(124, 58, 237, 0.05);
        }
        .loading-spinner {
            border: 3px solid #cbd5e1;
            border-top: 3px solid #7c3aed;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Layout styles */
        .main-layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            grid-template-rows: auto 1fr;
            gap: 1rem;
            height: calc(100vh - 140px);
        }
        /* Grid overlay for rotation alignment */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }
        .grid-line-h, .grid-line-v {
            position: absolute;
            background: rgba(59, 130, 246, 0.3);
        }
        .grid-line-h {
            width: 100%;
            height: 1px;
        }
        .grid-line-v {
            height: 100%;
            width: 1px;
        }
        .grid-center-h, .grid-center-v {
            background: rgba(239, 68, 68, 0.5);
        }
        .grid-center-h {
            width: 100%;
            height: 2px;
        }
        .grid-center-v {
            height: 100%;
            width: 2px;
        }
        .params-panel {
            grid-column: 1;
            grid-row: 1 / 3;
            overflow-y: auto;
        }
        .images-panel {
            grid-column: 2;
            grid-row: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            min-height: 0;
        }
        .results-panel {
            grid-column: 2;
            grid-row: 2;
            overflow-y: auto;
        }
        .image-display {
            position: relative;
            background: #f8fafc;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
        }
        .image-display img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                height: auto;
            }
            .params-panel {
                grid-column: 1;
                grid-row: 1;
            }
            .images-panel {
                grid-column: 1;
                grid-row: 2;
                grid-template-columns: 1fr;
            }
            .results-panel {
                grid-column: 1;
                grid-row: 3;
            }
        }
    </style>
</head>
<body class="gradient-bg min-h-screen text-gray-900">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // API base URL
        const API_BASE = '/api';

        // Parameter configuration
        const PARAM_CONFIG = {
            threshold_method: {
                label: "Threshold Method",
                type: "select",
                options: ["otsu", "manual", "adaptive"],
                description: "Method for converting grayscale to binary"
            },
            manual_threshold: {
                label: "Manual Threshold",
                type: "range",
                min: 0, max: 255, step: 1,
                showWhen: (p) => p.threshold_method === "manual",
                description: "Threshold value (0-255)"
            },
            adaptive_block_size: {
                label: "Adaptive Block Size",
                type: "range",
                min: 3, max: 101, step: 2,
                showWhen: (p) => p.threshold_method === "adaptive",
                description: "Block size for adaptive threshold (odd number)"
            },
            adaptive_c: {
                label: "Adaptive C",
                type: "range",
                min: -20, max: 20, step: 1,
                showWhen: (p) => p.threshold_method === "adaptive",
                description: "Constant subtracted from mean"
            },
            morph_enabled: {
                label: "Morphological Operations",
                type: "checkbox",
                description: "Apply morphological cleanup"
            },
            morph_operation: {
                label: "Morph Operation",
                type: "select",
                options: ["close", "open", "dilate", "erode"],
                showWhen: (p) => p.morph_enabled,
                description: "Type of morphological operation"
            },
            morph_kernel_size: {
                label: "Morph Kernel Size",
                type: "range",
                min: 1, max: 15, step: 2,
                showWhen: (p) => p.morph_enabled,
                description: "Size of morphological kernel"
            },
            morph_iterations: {
                label: "Morph Iterations",
                type: "range",
                min: 1, max: 5, step: 1,
                showWhen: (p) => p.morph_enabled,
                description: "Number of iterations"
            },
            roi_enabled: {
                label: "ROI Detection",
                type: "checkbox",
                description: "Auto-detect circular region of interest"
            },
            roi_margin: {
                label: "ROI Margin",
                type: "range",
                min: 0, max: 50, step: 1,
                showWhen: (p) => p.roi_enabled,
                description: "Pixels to shrink from detected edge"
            },
            use_reference_threshold: {
                label: "Use Reference Threshold",
                type: "checkbox",
                description: "Apply reference threshold to test image"
            },
            min_flash_area: {
                label: "Min Flash Area",
                type: "range",
                min: 0, max: 1000, step: 10,
                description: "Minimum pixels to count as flash defect"
            },
            analyze_individual_holes: {
                label: "Analyze Individual Holes",
                type: "checkbox",
                description: "Enable per-hole flash detection and labeling"
            },
            min_hole_area: {
                label: "Min Hole Area",
                type: "range",
                min: 10, max: 500, step: 10,
                description: "Minimum pixels to count as a hole"
            },
            alignment_method: {
                label: "Alignment Method",
                type: "select",
                options: ["sift", "orb", "ecc", "none"],
                description: "Feature matching method for alignment"
            },
            ransac_threshold: {
                label: "RANSAC Threshold",
                type: "range",
                min: 1, max: 20, step: 0.5,
                showWhen: (p) => p.alignment_method !== "none",
                description: "Threshold for RANSAC outlier rejection"
            }
        };

        // Parameter Control Component
        function ParamControl({ name, config, value, onChange, params }) {
            if (config.showWhen && !config.showWhen(params)) {
                return null;
            }

            const id = `param-${name}`;

            return (
                <div className="mb-5">
                    <label className="block text-sm font-semibold text-gray-800 mb-2" htmlFor={id}>
                        {config.label}
                    </label>
                    <p className="text-xs text-gray-500 mb-2 break-words">{config.description}</p>

                    {config.type === "select" && (
                        <select
                            id={id}
                            value={value}
                            onChange={(e) => onChange(name, e.target.value)}
                            className="w-full bg-white border border-gray-300 rounded px-3 py-2 text-gray-900 focus:outline-none focus:border-purple-500"
                        >
                            {config.options.map(opt => (
                                <option key={opt} value={opt}>{opt}</option>
                            ))}
                        </select>
                    )}

                    {config.type === "range" && (
                        <div className="flex items-center gap-3">
                            <input
                                id={id}
                                type="range"
                                min={config.min}
                                max={config.max}
                                step={config.step}
                                value={value}
                                onChange={(e) => onChange(name, parseFloat(e.target.value))}
                                className="flex-1"
                            />
                            <span className="text-sm text-purple-600 w-12 text-right font-medium">{value}</span>
                        </div>
                    )}

                    {config.type === "checkbox" && (
                        <label className="flex items-center cursor-pointer">
                            <input
                                id={id}
                                type="checkbox"
                                checked={value}
                                onChange={(e) => onChange(name, e.target.checked)}
                                className="w-4 h-4 rounded border-gray-300 bg-white text-purple-600 focus:ring-purple-500"
                            />
                            <span className="ml-2 text-sm text-gray-600">Enabled</span>
                        </label>
                    )}
                </div>
            );
        }

        // Grid Overlay Component (dynamic grid size)
        function GridOverlay({ show, gridSize = 8 }) {
            if (!show) return null;

            const lines = [];
            const spacing = 100 / gridSize; // Calculate spacing percentage

            // Vertical lines
            for (let i = 1; i < gridSize; i++) {
                const pos = (i * spacing);
                lines.push(
                    <div key={`v${i}`} className="grid-line-v" style={{left: `${pos}%`}}></div>
                );
            }
            // Horizontal lines
            for (let i = 1; i < gridSize; i++) {
                const pos = (i * spacing);
                lines.push(
                    <div key={`h${i}`} className="grid-line-h" style={{top: `${pos}%`}}></div>
                );
            }
            // Center lines (red)
            lines.push(
                <div key="center-v" className="grid-center-v" style={{left: '50%'}}></div>,
                <div key="center-h" className="grid-center-h" style={{top: '50%'}}></div>
            );

            return <div className="grid-overlay">{lines}</div>;
        }

        // Image Display Component
        function ImageDisplay({ label, imageSrc, onUpload, uploadLabel, showRotationControls, rotation, onRotationChange, onRotationApply, gridSize, onGridSizeChange }) {
            const [dragOver, setDragOver] = useState(false);
            const [uploading, setUploading] = useState(false);
            const [showGrid, setShowGrid] = useState(false);
            const fileInputRef = React.useRef(null);

            const handleDrop = useCallback((e) => {
                e.preventDefault();
                setDragOver(false);
                const file = e.dataTransfer.files[0];
                if (file) handleFile(file);
            }, []);

            const handleFile = async (file) => {
                if (!onUpload) return;
                setUploading(true);
                await onUpload(file);
                setUploading(false);
                // Reset file input so the same file can be uploaded again
                if (fileInputRef.current) {
                    fileInputRef.current.value = '';
                }
            };

            return (
                <div className="image-display">
                    <div className="p-2 bg-white border-b border-gray-200">
                        <div className="flex justify-between items-center">
                            <h3 className="text-sm font-semibold text-purple-600">{label}</h3>
                            <div className="flex gap-2">
                                {showRotationControls && imageSrc && (
                                    <button
                                        onClick={() => setShowGrid(!showGrid)}
                                        className={`text-xs px-2 py-1 rounded ${showGrid ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        Grid {showGrid ? 'ON' : 'OFF'}
                                    </button>
                                )}
                                {onUpload && (
                                    <button
                                        onClick={() => fileInputRef.current?.click()}
                                        className="text-xs bg-purple-100 hover:bg-purple-200 text-purple-700 px-2 py-1 rounded"
                                    >
                                        {uploadLabel || 'Upload'}
                                    </button>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* Rotation Controls */}
                    {showRotationControls && imageSrc && (
                        <div className="p-2 bg-gray-50 border-b border-gray-200 space-y-2">
                            <div className="flex items-center gap-2">
                                <label className="text-xs font-medium text-gray-700 whitespace-nowrap">Rotate:</label>
                                <button
                                    onClick={() => onRotationChange && onRotationChange((rotation || 0) - 1)}
                                    className="text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 px-2 py-1 rounded font-bold"
                                    title="Rotate -1°"
                                >
                                    -1°
                                </button>
                                <input
                                    type="range"
                                    min="-180"
                                    max="180"
                                    step="1"
                                    value={rotation || 0}
                                    onChange={(e) => onRotationChange && onRotationChange(parseFloat(e.target.value))}
                                    className="flex-1"
                                />
                                <button
                                    onClick={() => onRotationChange && onRotationChange((rotation || 0) + 1)}
                                    className="text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 px-2 py-1 rounded font-bold"
                                    title="Rotate +1°"
                                >
                                    +1°
                                </button>
                                <span className="text-xs text-purple-600 font-medium w-12 text-right">{rotation || 0}°</span>
                                <button
                                    onClick={() => onRotationApply && onRotationApply()}
                                    className="text-xs bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded"
                                >
                                    Apply
                                </button>
                                <button
                                    onClick={() => onRotationChange && onRotationChange(0)}
                                    className="text-xs bg-gray-300 hover:bg-gray-400 text-gray-700 px-2 py-1 rounded"
                                >
                                    Reset
                                </button>
                            </div>
                            <div className="flex items-center gap-2">
                                <label className="text-xs font-medium text-gray-700 whitespace-nowrap">Grid:</label>
                                <input
                                    type="range"
                                    min="2"
                                    max="20"
                                    step="1"
                                    value={gridSize || 8}
                                    onChange={(e) => onGridSizeChange && onGridSizeChange(parseInt(e.target.value))}
                                    className="flex-1"
                                />
                                <span className="text-xs text-blue-600 font-medium w-12 text-right">{gridSize || 8}x{gridSize || 8}</span>
                            </div>
                        </div>
                    )}

                    <div
                        className={`flex-1 flex items-center justify-center p-4 relative overflow-hidden ${dragOver ? 'bg-purple-50' : ''}`}
                        onDragOver={(e) => { e.preventDefault(); setDragOver(true); }}
                        onDragLeave={() => setDragOver(false)}
                        onDrop={handleDrop}
                    >
                        {onUpload && (
                            <input
                                ref={fileInputRef}
                                type="file"
                                accept="image/*"
                                className="hidden"
                                onChange={(e) => e.target.files[0] && handleFile(e.target.files[0])}
                            />
                        )}
                        {uploading ? (
                            <div className="flex flex-col items-center">
                                <div className="loading-spinner mb-2"></div>
                                <span className="text-sm text-gray-600">Processing...</span>
                            </div>
                        ) : imageSrc ? (
                            <div key={imageSrc.substring(0, 100)} style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                <img
                                    src={`data:image/png;base64,${imageSrc}`}
                                    alt={label}
                                    style={{
                                        transform: `rotate(${rotation || 0}deg)`,
                                        transition: rotation ? 'transform 0.1s ease' : 'none',
                                        maxWidth: '90%',
                                        maxHeight: '90%',
                                        objectFit: 'contain'
                                    }}
                                />
                                <GridOverlay show={showGrid} gridSize={gridSize} />
                            </div>
                        ) : (
                            <div className="text-center text-gray-400">
                                <svg className="mx-auto h-12 w-12 mb-2" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                                    <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                                </svg>
                                <p className="text-sm">{uploadLabel || 'No image'}</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        // Results Display Component
        // Hole Details Table Component
        function HoleDetailsTable({ holeDetails, selectedHoleId, onHoleSelect }) {
            const [sortKey, setSortKey] = useState('hole_id');
            const [sortDesc, setSortDesc] = useState(false);
            const tableRef = React.useRef(null);

            if (!holeDetails || holeDetails.length === 0) return null;

            // Scroll to selected row when selectedHoleId changes
            React.useEffect(() => {
                if (selectedHoleId && tableRef.current) {
                    const row = tableRef.current.querySelector(`tr[data-hole-id="${selectedHoleId}"]`);
                    if (row) {
                        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            }, [selectedHoleId]);

            const handleSort = (key) => {
                if (sortKey === key) {
                    setSortDesc(!sortDesc);
                } else {
                    setSortKey(key);
                    setSortDesc(false);
                }
            };

            const sortedHoles = [...holeDetails].sort((a, b) => {
                let valA = a[sortKey];
                let valB = b[sortKey];

                if (typeof valA === 'string') {
                    return sortDesc ? valB.localeCompare(valA) : valA.localeCompare(valB);
                }

                return sortDesc ? valB - valA : valA - valB;
            });

            const getStatusClass = (status) => {
                if (status === 'Good') return 'text-green-600 bg-green-100';
                if (status === 'Minor Flash') return 'text-orange-600 bg-orange-100';
                return 'text-red-600 bg-red-100';
            };

            const downloadCSV = () => {
                const headers = ['Hole ID', 'Center X', 'Center Y', 'Area (px)', 'Flash Pixels', 'Flash %', 'Status'];
                const rows = holeDetails.map(hole => [
                    hole.hole_id,
                    hole.center_x,
                    hole.center_y,
                    hole.area,
                    hole.flash_pixels,
                    hole.flash_percentage.toFixed(2),
                    hole.status
                ]);

                const csvContent = [
                    headers.join(','),
                    ...rows.map(row => row.join(','))
                ].join('\n');

                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'hole_details.csv';
                link.click();
                URL.revokeObjectURL(url);
            };

            const SortIcon = ({ columnKey }) => {
                if (sortKey !== columnKey) return <span className="text-gray-400">⇅</span>;
                return sortDesc ? <span className="text-purple-600">▼</span> : <span className="text-purple-600">▲</span>;
            };

            return (
                <div className="card rounded-lg p-4 mt-4">
                    <div className="flex justify-between items-center mb-3">
                        <h3 className="text-lg font-semibold text-purple-600">Individual Hole Analysis</h3>
                        <button
                            onClick={downloadCSV}
                            className="text-sm bg-purple-600 hover:bg-purple-700 text-white px-3 py-1.5 rounded"
                        >
                            Export CSV
                        </button>
                    </div>

                    <div ref={tableRef} style={{maxHeight: '400px', overflowY: 'auto'}}>
                        <table className="w-full text-sm border-collapse">
                            <thead className="bg-gray-100 sticky top-0">
                                <tr>
                                    <th className="px-3 py-2 text-left cursor-pointer hover:bg-gray-200" onClick={() => handleSort('hole_id')}>
                                        Hole ID <SortIcon columnKey="hole_id" />
                                    </th>
                                    <th className="px-3 py-2 text-left cursor-pointer hover:bg-gray-200" onClick={() => handleSort('center_x')}>
                                        Position <SortIcon columnKey="center_x" />
                                    </th>
                                    <th className="px-3 py-2 text-right cursor-pointer hover:bg-gray-200" onClick={() => handleSort('area')}>
                                        Area (px) <SortIcon columnKey="area" />
                                    </th>
                                    <th className="px-3 py-2 text-right cursor-pointer hover:bg-gray-200" onClick={() => handleSort('flash_pixels')}>
                                        Flash Pixels <SortIcon columnKey="flash_pixels" />
                                    </th>
                                    <th className="px-3 py-2 text-right cursor-pointer hover:bg-gray-200" onClick={() => handleSort('flash_percentage')}>
                                        Flash % <SortIcon columnKey="flash_percentage" />
                                    </th>
                                    <th className="px-3 py-2 text-center cursor-pointer hover:bg-gray-200" onClick={() => handleSort('status')}>
                                        Status <SortIcon columnKey="status" />
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                {sortedHoles.map(hole => (
                                    <tr
                                        key={hole.hole_id}
                                        data-hole-id={hole.hole_id}
                                        onClick={() => onHoleSelect && onHoleSelect(hole.hole_id)}
                                        className={`border-b border-gray-200 cursor-pointer transition-colors ${
                                            selectedHoleId === hole.hole_id
                                                ? 'bg-purple-100 hover:bg-purple-200'
                                                : 'hover:bg-gray-50'
                                        }`}
                                    >
                                        <td className="px-3 py-2 font-medium text-purple-600">{hole.hole_id}</td>
                                        <td className="px-3 py-2 text-gray-600">({hole.center_x}, {hole.center_y})</td>
                                        <td className="px-3 py-2 text-right text-gray-900">{hole.area.toLocaleString()}</td>
                                        <td className="px-3 py-2 text-right text-gray-900">{hole.flash_pixels.toLocaleString()}</td>
                                        <td className="px-3 py-2 text-right font-medium text-gray-900">{hole.flash_percentage.toFixed(2)}%</td>
                                        <td className="px-3 py-2 text-center">
                                            <span className={`px-2 py-1 rounded text-xs font-medium ${getStatusClass(hole.status)}`}>
                                                {hole.status}
                                            </span>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>

                    <div className="mt-3 text-xs text-gray-600">
                        Total holes detected: {holeDetails.length}
                    </div>
                </div>
            );
        }

        function ResultsDisplay({ result, images }) {
            const [showHoleLabels, setShowHoleLabels] = useState(true);
            const [selectedHoleId, setSelectedHoleId] = useState(null);
            const overlayImageRef = React.useRef(null);

            if (!result) return null;

            // Handle clicking on the overlay image to select a hole
            const handleImageClick = (e) => {
                if (!result.hole_details || !overlayImageRef.current) return;

                const rect = overlayImageRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Calculate actual image coordinates (accounting for object-fit: contain)
                const imgNaturalWidth = overlayImageRef.current.naturalWidth;
                const imgNaturalHeight = overlayImageRef.current.naturalHeight;
                const displayWidth = rect.width;
                const displayHeight = rect.height;

                // Calculate scale and offset for object-fit: contain
                const imgRatio = imgNaturalWidth / imgNaturalHeight;
                const displayRatio = displayWidth / displayHeight;

                let scale, offsetX = 0, offsetY = 0;

                if (imgRatio > displayRatio) {
                    // Image is wider - fit to width
                    scale = displayWidth / imgNaturalWidth;
                    offsetY = (displayHeight - imgNaturalHeight * scale) / 2;
                } else {
                    // Image is taller - fit to height
                    scale = displayHeight / imgNaturalHeight;
                    offsetX = (displayWidth - imgNaturalWidth * scale) / 2;
                }

                // Convert click position to image coordinates
                const imgX = (x - offsetX) / scale;
                const imgY = (y - offsetY) / scale;

                // Find closest hole to click position (within 50 pixels)
                let closestHole = null;
                let minDistance = 50;

                result.hole_details.forEach(hole => {
                    const dx = hole.center_x - imgX;
                    const dy = hole.center_y - imgY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < minDistance) {
                        minDistance = distance;
                        closestHole = hole;
                    }
                });

                if (closestHole) {
                    setSelectedHoleId(closestHole.hole_id);
                }
            };

            const getFlashClass = (pct) => {
                if (pct < 5) return 'result-good';
                if (pct < 20) return 'result-warning';
                return 'result-bad';
            };

            const downloadImage = (base64Data, filename) => {
                const link = document.createElement('a');
                link.href = `data:image/png;base64,${base64Data}`;
                link.download = filename;
                link.click();
            };

            return (
                <div className="card rounded-lg p-4">
                    <h3 className="text-lg font-semibold mb-4 text-purple-600">Detection Results</h3>

                    {/* Metrics Grid */}
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div className="bg-gray-100 rounded-lg p-3 text-center border border-gray-200">
                            <div className={`text-2xl font-bold ${getFlashClass(result.flash_percentage)}`}>
                                {result.flash_percentage.toFixed(2)}%
                            </div>
                            <div className="text-xs text-gray-600">Flash Percentage</div>
                        </div>
                        <div className="bg-gray-100 rounded-lg p-3 text-center border border-gray-200">
                            <div className="text-2xl font-bold text-blue-600">{result.iou.toFixed(1)}%</div>
                            <div className="text-xs text-gray-600">IoU (Alignment)</div>
                        </div>
                        <div className="bg-gray-100 rounded-lg p-3 text-center border border-gray-200">
                            <div className="text-xl font-bold text-green-600">{result.flash_pixels.toLocaleString()}</div>
                            <div className="text-xs text-gray-600">Flash Pixels</div>
                        </div>
                        <div className="bg-gray-100 rounded-lg p-3 text-center border border-gray-200">
                            <div className="text-xl font-bold text-yellow-600">{result.rotation_degrees.toFixed(2)}°</div>
                            <div className="text-xs text-gray-600">Rotation</div>
                        </div>
                    </div>

                    {/* Additional metrics */}
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-2 text-sm mb-4">
                        <div className="text-gray-600">Reference openings: <span className="text-gray-900 font-medium">{result.reference_opening_pixels.toLocaleString()}</span></div>
                        <div className="text-gray-600">Test openings: <span className="text-gray-900 font-medium">{result.test_opening_pixels.toLocaleString()}</span></div>
                        <div className="text-gray-600">Threshold: <span className="text-gray-900 font-medium">{result.threshold_value}</span></div>
                        <div className="text-gray-600">Scale: <span className="text-gray-900 font-medium">{result.scale?.toFixed(3) || '1.000'}</span></div>
                    </div>

                    {/* Alignment quality warning */}
                    {result.iou < 70 && (
                        <div className="bg-yellow-100 border border-yellow-400 text-yellow-800 px-3 py-2 rounded text-sm mb-4">
                            ⚠️ Low alignment quality (IoU: {result.iou.toFixed(1)}%). Try adjusting alignment parameters or ensure images are similar.
                        </div>
                    )}

                    {/* Result Images Side by Side */}
                    {images && images.test_flash && images.overlay && (
                        <div className="grid grid-cols-2 gap-4">
                            {/* Test + Flash */}
                            <div className="image-display">
                                <div className="p-2 bg-white border-b border-gray-200">
                                    <div className="flex justify-between items-center">
                                        <h4 className="text-sm font-semibold text-purple-600">Test + Flash (Red)</h4>
                                        <button
                                            onClick={() => downloadImage(images.test_flash, 'test_flash.png')}
                                            className="text-xs bg-purple-100 hover:bg-purple-200 text-purple-700 px-2 py-1 rounded"
                                        >
                                            Download
                                        </button>
                                    </div>
                                </div>
                                <div className="flex-1 flex items-center justify-center p-4" style={{height: '350px'}}>
                                    <img src={`data:image/png;base64,${images.test_flash}`} alt="Test with Flash" style={{width: '100%', height: '100%', objectFit: 'contain'}} />
                                </div>
                            </div>

                            {/* Overlay */}
                            <div className="image-display">
                                <div className="p-2 bg-white border-b border-gray-200">
                                    <div className="flex justify-between items-center">
                                        <h4 className="text-sm font-semibold text-purple-600">Overlay</h4>
                                        <div className="flex items-center gap-2">
                                            {/* Toggle for labeled overlay */}
                                            {images.labeled_overlay && (
                                                <label className="flex items-center gap-1 text-xs cursor-pointer">
                                                    <input
                                                        type="checkbox"
                                                        checked={showHoleLabels}
                                                        onChange={(e) => setShowHoleLabels(e.target.checked)}
                                                        className="cursor-pointer"
                                                    />
                                                    <span className="text-gray-700">Show Hole Labels</span>
                                                </label>
                                            )}
                                            <button
                                                onClick={() => downloadImage(showHoleLabels && images.labeled_overlay ? images.labeled_overlay : images.overlay, 'overlay.png')}
                                                className="text-xs bg-purple-100 hover:bg-purple-200 text-purple-700 px-2 py-1 rounded"
                                            >
                                                Download
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                <div className="flex-1 flex items-center justify-center p-4" style={{height: '350px'}}>
                                    <img
                                        ref={overlayImageRef}
                                        src={`data:image/png;base64,${showHoleLabels && images.labeled_overlay ? images.labeled_overlay : images.overlay}`}
                                        alt="Overlay"
                                        style={{
                                            width: '100%',
                                            height: '100%',
                                            objectFit: 'contain',
                                            cursor: result.hole_details && showHoleLabels ? 'pointer' : 'default'
                                        }}
                                        onClick={showHoleLabels ? handleImageClick : undefined}
                                    />
                                </div>
                                <div className="p-2 bg-gray-50 border-t border-gray-200 text-xs text-gray-600">
                                    Yellow: Material Match | Black: Holes Match | Bright Red: Flash Defect
                                    {showHoleLabels && images.labeled_overlay && (
                                        <span> | Green: Good Holes | Orange: Minor Flash | Red: Flash Defect</span>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Individual Hole Details Table */}
                    {result.hole_details && result.hole_details.length > 0 && (
                        <HoleDetailsTable
                            holeDetails={result.hole_details}
                            selectedHoleId={selectedHoleId}
                            onHoleSelect={setSelectedHoleId}
                        />
                    )}
                </div>
            );
        }

        // Main App Component
        function App() {
            const [params, setParams] = useState({
                threshold_method: "manual",
                manual_threshold: 119,
                adaptive_block_size: 51,
                adaptive_c: 5,
                morph_enabled: true,
                morph_operation: "close",
                morph_kernel_size: 3,
                morph_iterations: 1,
                roi_enabled: true,
                roi_margin: 10,
                use_reference_threshold: true,
                min_flash_area: 100,
                alignment_method: "orb",
                ransac_threshold: 5.5,
                analyze_individual_holes: false,
                min_hole_area: 50
            });

            const [referencePreview, setReferencePreview] = useState(null);
            const [testPreview, setTestPreview] = useState(null);
            const [referenceInfo, setReferenceInfo] = useState(null);
            const [result, setResult] = useState(null);
            const [resultImages, setResultImages] = useState(null);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            const [hasReference, setHasReference] = useState(false);
            const [testImageFile, setTestImageFile] = useState(null);
            const [referenceRotation, setReferenceRotation] = useState(0);
            const [appliedRotation, setAppliedRotation] = useState(0);
            const [isApplyingRotation, setIsApplyingRotation] = useState(false);
            const [previewVersion, setPreviewVersion] = useState(0);
            const [gridSize, setGridSize] = useState(8); // Grid divisions (8x8 by default)

            // Load initial params from server
            useEffect(() => {
                fetch(`${API_BASE}/params`)
                    .then(res => res.json())
                    .then(data => setParams(prev => ({ ...prev, ...data })))
                    .catch(err => console.error('Failed to load params:', err));
            }, []);

            // Check for and load saved reference on page load
            useEffect(() => {
                const loadSavedReference = async () => {
                    try {
                        // Check if saved reference exists
                        const statusRes = await fetch(`${API_BASE}/reference/status`);
                        const statusData = await statusRes.json();

                        if (statusData.has_saved_reference) {
                            console.log('Found saved reference, loading...');

                            // Get the preview
                            const previewRes = await fetch(`${API_BASE}/reference/preview`);
                            const previewData = await previewRes.json();

                            if (previewData.status === 'success') {
                                setReferencePreview(previewData.binary);
                                setReferenceInfo(previewData.info);
                                setHasReference(true);
                                setReferenceRotation(statusData.config?.rotation_angle || 0);
                                setAppliedRotation(statusData.config?.rotation_angle || 0);

                                console.log('✓ Loaded saved reference', {
                                    rotation: statusData.config?.rotation_angle,
                                    timestamp: statusData.config?.upload_timestamp
                                });
                            }
                        }
                    } catch (err) {
                        console.error('Failed to check for saved reference:', err);
                    }
                };

                loadSavedReference();
            }, []);

            // Update server params when local params change
            const updateParams = useCallback(async (newParams) => {
                try {
                    await fetch(`${API_BASE}/params`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(newParams)
                    });
                } catch (err) {
                    console.error('Failed to update params:', err);
                }
            }, []);

            // Debounce timer ref
            const debounceTimer = React.useRef(null);

            const handleParamChange = (name, value) => {
                const newParams = { ...params, [name]: value };
                setParams(newParams);
                updateParams(newParams);

                // Clear existing timer
                if (debounceTimer.current) {
                    clearTimeout(debounceTimer.current);
                }

                // Auto-refresh reference preview for binarization and morphology params
                const refParams = ['threshold_method', 'manual_threshold', 'adaptive_block_size',
                    'adaptive_c', 'morph_enabled', 'morph_operation', 'morph_kernel_size',
                    'morph_iterations', 'roi_enabled', 'roi_margin'];

                if (hasReference && refParams.includes(name)) {
                    debounceTimer.current = setTimeout(() => refreshReferencePreview(), 300);
                }

                // Auto-rerun detection if test image exists
                if (testImageFile && hasReference) {
                    debounceTimer.current = setTimeout(() => rerunDetection(), 500);
                }
            };

            const refreshReferencePreview = async () => {
                // Don't refresh if we're applying rotation
                if (isApplyingRotation) {
                    console.log('Skipping refresh - rotation in progress');
                    return;
                }

                console.log('refreshReferencePreview called');

                try {
                    const res = await fetch(`${API_BASE}/reference/preview`);
                    const data = await res.json();
                    if (data.status === 'success') {
                        console.log('Preview refreshed from server, first 50 chars:', data.binary.substring(0, 50));
                        setReferencePreview(data.binary);
                        setReferenceInfo(data.info);
                        setPreviewVersion(v => v + 1);
                    }
                } catch (err) {
                    console.error('Failed to refresh preview:', err);
                }
            };

            const applyReferenceRotation = async () => {
                if (!hasReference || referenceRotation === appliedRotation) return;

                setIsApplyingRotation(true);
                setLoading(true);

                // IMPORTANT: CSS rotates opposite direction from OpenCV
                // CSS: positive = clockwise, OpenCV: positive = counter-clockwise
                // So we need to negate the angle to match the preview
                const angleToApply = -referenceRotation;

                console.log(`User rotated to: ${referenceRotation}°, sending to backend: ${angleToApply}°`);

                try {
                    const res = await fetch(`${API_BASE}/reference/rotate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ angle: angleToApply })
                    });
                    const data = await res.json();

                    console.log('Rotation response:', {
                        status: data.status,
                        angle: data.angle,
                        hasBinary: !!data.binary,
                        binaryLength: data.binary?.length
                    });

                    if (data.status === 'success') {
                        console.log('Setting rotated preview, first 50 chars:', data.binary.substring(0, 50));

                        // First, reset rotation to 0
                        setReferenceRotation(0);
                        setAppliedRotation(0);

                        // Force update the preview (which is already rotated by backend)
                        // Use functional update to ensure React sees it as a change
                        setReferencePreview(() => data.binary);
                        setReferenceInfo(() => data.info);
                        setPreviewVersion(v => v + 1);

                        console.log('Applied rotation successfully, slider reset to 0, preview updated');

                        // Re-run detection if test exists
                        if (testImageFile) {
                            await rerunDetection();
                        }
                    } else {
                        setError(data.error);
                    }
                } catch (err) {
                    setError('Failed to rotate reference image');
                    console.error('Rotation error:', err);
                }

                setLoading(false);
                setIsApplyingRotation(false);
            };

            const uploadReference = async (file) => {
                setError(null);
                setLoading(true);
                const formData = new FormData();
                formData.append('file', file);

                try {
                    const res = await fetch(`${API_BASE}/reference`, {
                        method: 'POST',
                        body: formData
                    });
                    const data = await res.json();

                    console.log('Reference upload response:', data);

                    if (data.status === 'success') {
                        setReferencePreview(data.preview);
                        setReferenceInfo(data.info);
                        setHasReference(true);
                        setReferenceRotation(0);
                        setAppliedRotation(0);
                        // Clear test results when new reference is uploaded
                        setTestPreview(null);
                        setTestImageFile(null);
                        setResult(null);
                        setResultImages(null);
                        console.log('Reference uploaded successfully');
                    } else {
                        setError(data.error);
                    }
                } catch (err) {
                    setError('Failed to upload reference image');
                    console.error('Upload error:', err);
                }
                setLoading(false);
            };

            const uploadTest = async (file) => {
                if (!hasReference) {
                    setError('Please upload a reference image first');
                    return;
                }

                setError(null);
                setLoading(true);

                // Store the file for rerun detection
                setTestImageFile(file);

                const formData = new FormData();
                formData.append('file', file);

                try {
                    const res = await fetch(`${API_BASE}/detect`, {
                        method: 'POST',
                        body: formData
                    });
                    const data = await res.json();

                    if (data.status === 'success') {
                        setResult(data.result);
                        setResultImages(data.images);
                        setTestPreview(data.images.test_binary);
                    } else {
                        setError(data.error);
                    }
                } catch (err) {
                    setError('Failed to run detection');
                }

                setLoading(false);
            };

            const rerunDetection = async () => {
                if (!testImageFile || !hasReference) return;

                setLoading(true);
                try {
                    const formData = new FormData();
                    formData.append('file', testImageFile);

                    const res = await fetch(`${API_BASE}/detect`, {
                        method: 'POST',
                        body: formData
                    });
                    const data = await res.json();

                    if (data.status === 'success') {
                        setResult(data.result);
                        setResultImages(data.images);
                        setTestPreview(data.images.test_binary);
                    }
                } catch (err) {
                    console.error('Failed to rerun detection:', err);
                }
                setLoading(false);
            };

            const resetParams = async () => {
                try {
                    const res = await fetch(`${API_BASE}/params/reset`, { method: 'POST' });
                    const data = await res.json();
                    if (data.status === 'success') {
                        setParams(data.params);
                        if (hasReference) refreshReferencePreview();
                        if (testImageFile) rerunDetection();
                    }
                } catch (err) {
                    setError('Failed to reset parameters');
                }
            };

            return (
                <div className="container mx-auto px-4 py-6" style={{maxWidth: '1800px'}}>
                    {/* Header */}
                    <header className="text-center mb-4">
                        <h1 className="text-3xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-purple-600 to-pink-600">
                            Flash Detector
                        </h1>
                        <p className="text-gray-600 mt-1">Industrial Vision Inspection System</p>
                    </header>

                    {/* Error Display */}
                    {error && (
                        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
                            {error}
                            <button onClick={() => setError(null)} className="float-right font-bold">&times;</button>
                        </div>
                    )}

                    {/* Main Layout */}
                    <div className="main-layout">
                        {/* Left Panel - Parameters */}
                        <div className="params-panel">
                            <div className="card rounded-lg p-4 h-full flex flex-col overflow-x-hidden">
                                <div className="flex justify-between items-center mb-4 flex-shrink-0">
                                    <h2 className="text-xl font-semibold text-purple-600">Parameters</h2>
                                    <button
                                        onClick={resetParams}
                                        className="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 px-2 py-1 rounded"
                                    >
                                        Reset
                                    </button>
                                </div>

                                <div className="flex-1 overflow-y-auto overflow-x-hidden pr-1 space-y-1">
                                    {/* Step 1: Binarization */}
                                    <div className="mb-6">
                                        <h3 className="text-base font-bold text-gray-800 mb-3 mt-3 pb-2 border-b-2 border-purple-400 bg-purple-50 px-2 py-2 rounded">
                                            1. Binarization
                                        </h3>
                                        <div className="px-1 mt-4">
                                            {['threshold_method', 'manual_threshold', 'adaptive_block_size', 'adaptive_c'].map(name => (
                                                <ParamControl
                                                    key={name}
                                                    name={name}
                                                    config={PARAM_CONFIG[name]}
                                                    value={params[name]}
                                                    onChange={handleParamChange}
                                                    params={params}
                                                />
                                            ))}
                                        </div>
                                    </div>

                                    {/* Step 2: Morphology */}
                                    <div className="mb-6">
                                        <h3 className="text-base font-bold text-gray-800 mb-3 mt-3 pb-2 border-b-2 border-purple-400 bg-purple-50 px-2 py-2 rounded">
                                            2. Morphology
                                        </h3>
                                        <div className="px-1 mt-4">
                                            {['morph_enabled', 'morph_operation', 'morph_kernel_size', 'morph_iterations'].map(name => (
                                                <ParamControl
                                                    key={name}
                                                    name={name}
                                                    config={PARAM_CONFIG[name]}
                                                    value={params[name]}
                                                    onChange={handleParamChange}
                                                    params={params}
                                                />
                                            ))}
                                        </div>
                                    </div>

                                    {/* Step 3: Region of Interest */}
                                    <div className="mb-6">
                                        <h3 className="text-base font-bold text-gray-800 mb-3 mt-3 pb-2 border-b-2 border-purple-400 bg-purple-50 px-2 py-2 rounded">
                                            3. Region of Interest
                                        </h3>
                                        <div className="px-1 mt-4">
                                            {['roi_enabled', 'roi_margin'].map(name => (
                                                <ParamControl
                                                    key={name}
                                                    name={name}
                                                    config={PARAM_CONFIG[name]}
                                                    value={params[name]}
                                                    onChange={handleParamChange}
                                                    params={params}
                                                />
                                            ))}
                                        </div>
                                    </div>

                                    {/* Step 4: Alignment */}
                                    <div className="mb-6">
                                        <h3 className="text-base font-bold text-gray-800 mb-3 mt-3 pb-2 border-b-2 border-purple-400 bg-purple-50 px-2 py-2 rounded">
                                            4. Alignment
                                        </h3>
                                        <div className="px-1 mt-4">
                                            {['alignment_method', 'ransac_threshold'].map(name => (
                                                <ParamControl
                                                    key={name}
                                                    name={name}
                                                    config={PARAM_CONFIG[name]}
                                                    value={params[name]}
                                                    onChange={handleParamChange}
                                                    params={params}
                                                />
                                            ))}
                                        </div>
                                    </div>

                                    {/* Step 5: Flash Detection */}
                                    <div className="mb-6">
                                        <h3 className="text-base font-bold text-gray-800 mb-3 mt-3 pb-2 border-b-2 border-purple-400 bg-purple-50 px-2 py-2 rounded">
                                            5. Flash Detection
                                        </h3>
                                        <div className="px-1 mt-4">
                                            {['use_reference_threshold', 'min_flash_area', 'analyze_individual_holes', 'min_hole_area'].map(name => (
                                                <ParamControl
                                                    key={name}
                                                    name={name}
                                                    config={PARAM_CONFIG[name]}
                                                    value={params[name]}
                                                    onChange={handleParamChange}
                                                    params={params}
                                                />
                                            ))}
                                        </div>
                                    </div>
                                </div>

                                {/* Reference Info */}
                                {referenceInfo && (
                                    <div className="mt-4">
                                        {/* Show indicator if using saved reference */}
                                        {appliedRotation !== 0 && (
                                            <div className="mb-2 p-2 bg-green-50 border border-green-300 rounded text-xs text-green-800">
                                                ✓ Using saved golden image (rotation: {appliedRotation}°)
                                            </div>
                                        )}
                                        <div className="p-3 bg-gray-100 rounded text-xs border border-gray-200">
                                            <div className="text-gray-600">Threshold: <span className="text-gray-900 font-medium">{referenceInfo.threshold}</span></div>
                                            <div className="text-gray-600">ROI Center: <span className="text-gray-900 font-medium">{referenceInfo.roi_center?.join(', ')}</span></div>
                                            <div className="text-gray-600">ROI Radius: <span className="text-gray-900 font-medium">{referenceInfo.roi_radius}px</span></div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* Top Right - Images Side by Side */}
                        <div className="images-panel">
                            <ImageDisplay
                                label="Reference Image (Golden Sample)"
                                imageSrc={referencePreview}
                                onUpload={uploadReference}
                                uploadLabel="Upload Reference"
                                showRotationControls={true}
                                rotation={referenceRotation}
                                onRotationChange={setReferenceRotation}
                                onRotationApply={applyReferenceRotation}
                                gridSize={gridSize}
                                onGridSizeChange={setGridSize}
                            />
                            <ImageDisplay
                                label="Test Image (To Inspect)"
                                imageSrc={testPreview}
                                onUpload={uploadTest}
                                uploadLabel="Upload Test"
                            />
                        </div>

                        {/* Bottom Right - Results */}
                        <div className="results-panel">
                            {loading && (
                                <div className="flex justify-center items-center py-8">
                                    <div className="loading-spinner mr-3"></div>
                                    <span className="text-gray-600">Processing...</span>
                                </div>
                            )}

                            {result ? (
                                <ResultsDisplay result={result} images={resultImages} />
                            ) : !hasReference ? (
                                <div className="card rounded-lg p-6 text-center">
                                    <h3 className="text-lg font-semibold mb-4 text-purple-600">Getting Started</h3>
                                    <ol className="text-left text-gray-600 space-y-2 max-w-md mx-auto">
                                        <li>1. Upload a <strong className="text-gray-900">Reference Image</strong> (golden sample without defects)</li>
                                        <li>2. Adjust <strong className="text-gray-900">Parameters</strong> on the left to optimize binarization</li>
                                        <li>3. Upload a <strong className="text-gray-900">Test Image</strong> to inspect for flash defects</li>
                                        <li>4. View results in real-time as you adjust parameters</li>
                                    </ol>
                                </div>
                            ) : null}
                        </div>
                    </div>

                    {/* Footer */}
                    <footer className="text-center text-gray-500 text-sm mt-4 pb-4">
                        Flash Detector v1.0 | Solomon-3D Vision Systems
                    </footer>
                </div>
            );
        }

        // Render the app
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
