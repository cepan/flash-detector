<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flash Detector - Industrial Vision Inspection</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
        }
        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        .slider-track {
            background: linear-gradient(to right, #4f46e5, #7c3aed);
        }
        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #cbd5e1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #7c3aed;
            cursor: pointer;
            border: 2px solid white;
        }
        .result-good { color: #059669; }
        .result-warning { color: #d97706; }
        .result-bad { color: #dc2626; }
        .image-container {
            position: relative;
            background: #f8fafc;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #e2e8f0;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .drop-zone {
            border: 2px dashed #94a3b8;
            transition: all 0.3s ease;
            background: #f8fafc;
        }
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #7c3aed;
            background: rgba(124, 58, 237, 0.05);
        }
        .loading-spinner {
            border: 3px solid #cbd5e1;
            border-top: 3px solid #7c3aed;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Layout styles */
        .main-layout {
            display: grid;
            grid-template-columns: 350px 1fr;
            grid-template-rows: auto 1fr;
            gap: 1rem;
            height: calc(100vh - 140px);
        }
        /* Grid overlay for rotation alignment */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }
        .grid-line-h, .grid-line-v {
            position: absolute;
            background: rgba(59, 130, 246, 0.3);
        }
        .grid-line-h {
            width: 100%;
            height: 1px;
        }
        .grid-line-v {
            height: 100%;
            width: 1px;
        }
        .grid-center-h, .grid-center-v {
            background: rgba(239, 68, 68, 0.5);
        }
        .grid-center-h {
            width: 100%;
            height: 2px;
        }
        .grid-center-v {
            height: 100%;
            width: 2px;
        }
        .params-panel {
            grid-column: 1;
            grid-row: 1 / 3;
            overflow-y: auto;
        }
        .images-panel {
            grid-column: 2;
            grid-row: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            min-height: 0;
        }
        .results-panel {
            grid-column: 2;
            grid-row: 2;
            overflow-y: auto;
        }
        .image-display {
            position: relative;
            background: #f8fafc;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
        }
        .image-display img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                height: auto;
            }
            .params-panel {
                grid-column: 1;
                grid-row: 1;
            }
            .images-panel {
                grid-column: 1;
                grid-row: 2;
                grid-template-columns: 1fr;
            }
            .results-panel {
                grid-column: 1;
                grid-row: 3;
            }
        }
    </style>
</head>
<body class="gradient-bg min-h-screen text-gray-900">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        // API base URL
        const API_BASE = '/api';

        // Parameter configuration
        const PARAM_CONFIG = {
            threshold_method: {
                label: "Threshold Method",
                type: "select",
                options: ["otsu", "manual", "adaptive"],
                description: "Method for converting grayscale to binary"
            },
            manual_threshold: {
                label: "Manual Threshold",
                type: "range",
                min: 0, max: 255, step: 1,
                showWhen: (p) => p.threshold_method === "manual",
                description: "Threshold value (0-255)"
            },
            adaptive_block_size: {
                label: "Adaptive Block Size",
                type: "range",
                min: 3, max: 101, step: 2,
                showWhen: (p) => p.threshold_method === "adaptive",
                description: "Block size for adaptive threshold (odd number)"
            },
            adaptive_c: {
                label: "Adaptive C",
                type: "range",
                min: -20, max: 20, step: 1,
                showWhen: (p) => p.threshold_method === "adaptive",
                description: "Constant subtracted from mean"
            },
            morph_enabled: {
                label: "Morphological Operations",
                type: "checkbox",
                description: "Apply morphological cleanup"
            },
            morph_operation: {
                label: "Morph Operation",
                type: "select",
                options: ["close", "open", "dilate", "erode"],
                showWhen: (p) => p.morph_enabled,
                description: "Type of morphological operation"
            },
            morph_kernel_size: {
                label: "Morph Kernel Size",
                type: "range",
                min: 1, max: 15, step: 2,
                showWhen: (p) => p.morph_enabled,
                description: "Size of morphological kernel"
            },
            morph_iterations: {
                label: "Morph Iterations",
                type: "range",
                min: 1, max: 5, step: 1,
                showWhen: (p) => p.morph_enabled,
                description: "Number of iterations"
            },
            roi_enabled: {
                label: "ROI Detection",
                type: "checkbox",
                description: "Auto-detect circular region of interest"
            },
            roi_margin: {
                label: "ROI Margin",
                type: "range",
                min: 0, max: 50, step: 1,
                showWhen: (p) => p.roi_enabled,
                description: "Pixels to shrink from detected edge"
            },
            use_reference_threshold: {
                label: "Use Reference Threshold",
                type: "checkbox",
                description: "Apply reference threshold to test image"
            },
            min_flash_area: {
                label: "Min Flash Area",
                type: "range",
                min: 0, max: 1000, step: 10,
                description: "Minimum pixels to count as flash defect"
            },
            alignment_method: {
                label: "Alignment Method",
                type: "select",
                options: ["sift", "orb", "ecc", "none"],
                description: "Feature matching method for alignment"
            },
            ransac_threshold: {
                label: "RANSAC Threshold",
                type: "range",
                min: 1, max: 20, step: 0.5,
                showWhen: (p) => p.alignment_method !== "none",
                description: "Threshold for RANSAC outlier rejection"
            }
        };

        // Parameter Control Component
        function ParamControl({ name, config, value, onChange, params }) {
            if (config.showWhen && !config.showWhen(params)) {
                return null;
            }

            const id = `param-${name}`;

            return (
                <div className="mb-4">
                    <label className="block text-sm font-medium text-gray-700 mb-1" htmlFor={id}>
                        {config.label}
                        <span className="text-xs text-gray-500 ml-2">({config.description})</span>
                    </label>

                    {config.type === "select" && (
                        <select
                            id={id}
                            value={value}
                            onChange={(e) => onChange(name, e.target.value)}
                            className="w-full bg-white border border-gray-300 rounded px-3 py-2 text-gray-900 focus:outline-none focus:border-purple-500"
                        >
                            {config.options.map(opt => (
                                <option key={opt} value={opt}>{opt}</option>
                            ))}
                        </select>
                    )}

                    {config.type === "range" && (
                        <div className="flex items-center gap-3">
                            <input
                                id={id}
                                type="range"
                                min={config.min}
                                max={config.max}
                                step={config.step}
                                value={value}
                                onChange={(e) => onChange(name, parseFloat(e.target.value))}
                                className="flex-1"
                            />
                            <span className="text-sm text-purple-600 w-12 text-right font-medium">{value}</span>
                        </div>
                    )}

                    {config.type === "checkbox" && (
                        <label className="flex items-center cursor-pointer">
                            <input
                                id={id}
                                type="checkbox"
                                checked={value}
                                onChange={(e) => onChange(name, e.target.checked)}
                                className="w-4 h-4 rounded border-gray-300 bg-white text-purple-600 focus:ring-purple-500"
                            />
                            <span className="ml-2 text-sm text-gray-600">Enabled</span>
                        </label>
                    )}
                </div>
            );
        }

        // Grid Overlay Component (8x8 grid)
        function GridOverlay({ show }) {
            if (!show) return null;

            const lines = [];
            // Vertical lines (every 12.5% for 8x8 grid)
            for (let i = 1; i < 8; i++) {
                const pos = (i * 12.5);
                lines.push(
                    <div key={`v${i}`} className="grid-line-v" style={{left: `${pos}%`}}></div>
                );
            }
            // Horizontal lines (every 12.5% for 8x8 grid)
            for (let i = 1; i < 8; i++) {
                const pos = (i * 12.5);
                lines.push(
                    <div key={`h${i}`} className="grid-line-h" style={{top: `${pos}%`}}></div>
                );
            }
            // Center lines (red)
            lines.push(
                <div key="center-v" className="grid-center-v" style={{left: '50%'}}></div>,
                <div key="center-h" className="grid-center-h" style={{top: '50%'}}></div>
            );

            return <div className="grid-overlay">{lines}</div>;
        }

        // Image Display Component
        function ImageDisplay({ label, imageSrc, onUpload, uploadLabel, showRotationControls, rotation, onRotationChange, onRotationApply }) {
            const [dragOver, setDragOver] = useState(false);
            const [uploading, setUploading] = useState(false);
            const [showGrid, setShowGrid] = useState(false);
            const fileInputRef = React.useRef(null);

            const handleDrop = useCallback((e) => {
                e.preventDefault();
                setDragOver(false);
                const file = e.dataTransfer.files[0];
                if (file) handleFile(file);
            }, []);

            const handleFile = async (file) => {
                if (!onUpload) return;
                setUploading(true);
                await onUpload(file);
                setUploading(false);
                // Reset file input so the same file can be uploaded again
                if (fileInputRef.current) {
                    fileInputRef.current.value = '';
                }
            };

            return (
                <div className="image-display">
                    <div className="p-2 bg-white border-b border-gray-200">
                        <div className="flex justify-between items-center">
                            <h3 className="text-sm font-semibold text-purple-600">{label}</h3>
                            <div className="flex gap-2">
                                {showRotationControls && imageSrc && (
                                    <button
                                        onClick={() => setShowGrid(!showGrid)}
                                        className={`text-xs px-2 py-1 rounded ${showGrid ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                    >
                                        Grid {showGrid ? 'ON' : 'OFF'}
                                    </button>
                                )}
                                {onUpload && (
                                    <button
                                        onClick={() => fileInputRef.current?.click()}
                                        className="text-xs bg-purple-100 hover:bg-purple-200 text-purple-700 px-2 py-1 rounded"
                                    >
                                        {uploadLabel || 'Upload'}
                                    </button>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* Rotation Controls */}
                    {showRotationControls && imageSrc && (
                        <div className="p-2 bg-gray-50 border-b border-gray-200">
                            <div className="flex items-center gap-2">
                                <label className="text-xs font-medium text-gray-700 whitespace-nowrap">Rotate:</label>
                                <input
                                    type="range"
                                    min="-180"
                                    max="180"
                                    step="1"
                                    value={rotation || 0}
                                    onChange={(e) => onRotationChange && onRotationChange(parseFloat(e.target.value))}
                                    className="flex-1"
                                />
                                <span className="text-xs text-purple-600 font-medium w-12 text-right">{rotation || 0}°</span>
                                <button
                                    onClick={() => onRotationApply && onRotationApply()}
                                    className="text-xs bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded"
                                >
                                    Apply
                                </button>
                                <button
                                    onClick={() => onRotationChange && onRotationChange(0)}
                                    className="text-xs bg-gray-300 hover:bg-gray-400 text-gray-700 px-2 py-1 rounded"
                                >
                                    Reset
                                </button>
                            </div>
                        </div>
                    )}

                    <div
                        className={`flex-1 flex items-center justify-center p-4 relative overflow-hidden ${dragOver ? 'bg-purple-50' : ''}`}
                        onDragOver={(e) => { e.preventDefault(); setDragOver(true); }}
                        onDragLeave={() => setDragOver(false)}
                        onDrop={handleDrop}
                    >
                        {onUpload && (
                            <input
                                ref={fileInputRef}
                                type="file"
                                accept="image/*"
                                className="hidden"
                                onChange={(e) => e.target.files[0] && handleFile(e.target.files[0])}
                            />
                        )}
                        {uploading ? (
                            <div className="flex flex-col items-center">
                                <div className="loading-spinner mb-2"></div>
                                <span className="text-sm text-gray-600">Processing...</span>
                            </div>
                        ) : imageSrc ? (
                            <div key={imageSrc.substring(0, 100)} style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                <img
                                    src={`data:image/png;base64,${imageSrc}`}
                                    alt={label}
                                    style={{
                                        transform: `rotate(${rotation || 0}deg)`,
                                        transition: rotation ? 'transform 0.1s ease' : 'none',
                                        maxWidth: '90%',
                                        maxHeight: '90%',
                                        objectFit: 'contain'
                                    }}
                                />
                                <GridOverlay show={showGrid} />
                            </div>
                        ) : (
                            <div className="text-center text-gray-400">
                                <svg className="mx-auto h-12 w-12 mb-2" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                                    <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                                </svg>
                                <p className="text-sm">{uploadLabel || 'No image'}</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        // Results Display Component
        function ResultsDisplay({ result, images }) {
            if (!result) return null;

            const getFlashClass = (pct) => {
                if (pct < 5) return 'result-good';
                if (pct < 20) return 'result-warning';
                return 'result-bad';
            };

            const downloadImage = (base64Data, filename) => {
                const link = document.createElement('a');
                link.href = `data:image/png;base64,${base64Data}`;
                link.download = filename;
                link.click();
            };

            return (
                <div className="card rounded-lg p-4">
                    <h3 className="text-lg font-semibold mb-4 text-purple-600">Detection Results</h3>

                    {/* Metrics Grid */}
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div className="bg-gray-100 rounded-lg p-3 text-center border border-gray-200">
                            <div className={`text-2xl font-bold ${getFlashClass(result.flash_percentage)}`}>
                                {result.flash_percentage.toFixed(2)}%
                            </div>
                            <div className="text-xs text-gray-600">Flash Percentage</div>
                        </div>
                        <div className="bg-gray-100 rounded-lg p-3 text-center border border-gray-200">
                            <div className="text-2xl font-bold text-blue-600">{result.iou.toFixed(1)}%</div>
                            <div className="text-xs text-gray-600">IoU (Alignment)</div>
                        </div>
                        <div className="bg-gray-100 rounded-lg p-3 text-center border border-gray-200">
                            <div className="text-xl font-bold text-green-600">{result.flash_pixels.toLocaleString()}</div>
                            <div className="text-xs text-gray-600">Flash Pixels</div>
                        </div>
                        <div className="bg-gray-100 rounded-lg p-3 text-center border border-gray-200">
                            <div className="text-xl font-bold text-yellow-600">{result.rotation_degrees.toFixed(2)}°</div>
                            <div className="text-xs text-gray-600">Rotation</div>
                        </div>
                    </div>

                    {/* Additional metrics */}
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-2 text-sm mb-4">
                        <div className="text-gray-600">Reference openings: <span className="text-gray-900 font-medium">{result.reference_opening_pixels.toLocaleString()}</span></div>
                        <div className="text-gray-600">Test openings: <span className="text-gray-900 font-medium">{result.test_opening_pixels.toLocaleString()}</span></div>
                        <div className="text-gray-600">Threshold: <span className="text-gray-900 font-medium">{result.threshold_value}</span></div>
                        <div className="text-gray-600">Scale: <span className="text-gray-900 font-medium">{result.scale?.toFixed(3) || '1.000'}</span></div>
                    </div>

                    {/* Alignment quality warning */}
                    {result.iou < 70 && (
                        <div className="bg-yellow-100 border border-yellow-400 text-yellow-800 px-3 py-2 rounded text-sm mb-4">
                            ⚠️ Low alignment quality (IoU: {result.iou.toFixed(1)}%). Try adjusting alignment parameters or ensure images are similar.
                        </div>
                    )}

                    {/* Result Images Side by Side */}
                    {images && images.test_flash && images.overlay && (
                        <div className="grid grid-cols-2 gap-4">
                            {/* Test + Flash */}
                            <div className="image-display">
                                <div className="p-2 bg-white border-b border-gray-200">
                                    <div className="flex justify-between items-center">
                                        <h4 className="text-sm font-semibold text-purple-600">Test + Flash (Red)</h4>
                                        <button
                                            onClick={() => downloadImage(images.test_flash, 'test_flash.png')}
                                            className="text-xs bg-purple-100 hover:bg-purple-200 text-purple-700 px-2 py-1 rounded"
                                        >
                                            Download
                                        </button>
                                    </div>
                                </div>
                                <div className="flex-1 flex items-center justify-center p-4" style={{height: '350px'}}>
                                    <img src={`data:image/png;base64,${images.test_flash}`} alt="Test with Flash" style={{width: '100%', height: '100%', objectFit: 'contain'}} />
                                </div>
                            </div>

                            {/* Overlay */}
                            <div className="image-display">
                                <div className="p-2 bg-white border-b border-gray-200">
                                    <div className="flex justify-between items-center">
                                        <h4 className="text-sm font-semibold text-purple-600">Overlay</h4>
                                        <button
                                            onClick={() => downloadImage(images.overlay, 'overlay.png')}
                                            className="text-xs bg-purple-100 hover:bg-purple-200 text-purple-700 px-2 py-1 rounded"
                                        >
                                            Download
                                        </button>
                                    </div>
                                </div>
                                <div className="flex-1 flex items-center justify-center p-4" style={{height: '350px'}}>
                                    <img src={`data:image/png;base64,${images.overlay}`} alt="Overlay" style={{width: '100%', height: '100%', objectFit: 'contain'}} />
                                </div>
                                <div className="p-2 bg-gray-50 border-t border-gray-200 text-xs text-gray-600">
                                    Yellow: Material Match | Black: Holes Match | Bright Red: Flash Defect
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        // Main App Component
        function App() {
            const [params, setParams] = useState({
                threshold_method: "otsu",
                manual_threshold: 128,
                adaptive_block_size: 51,
                adaptive_c: 5,
                morph_enabled: true,
                morph_operation: "close",
                morph_kernel_size: 3,
                morph_iterations: 1,
                roi_enabled: true,
                roi_margin: 10,
                use_reference_threshold: true,
                min_flash_area: 100,
                alignment_method: "sift",
                ransac_threshold: 5.0
            });

            const [referencePreview, setReferencePreview] = useState(null);
            const [testPreview, setTestPreview] = useState(null);
            const [referenceInfo, setReferenceInfo] = useState(null);
            const [result, setResult] = useState(null);
            const [resultImages, setResultImages] = useState(null);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            const [hasReference, setHasReference] = useState(false);
            const [testImageFile, setTestImageFile] = useState(null);
            const [referenceRotation, setReferenceRotation] = useState(0);
            const [appliedRotation, setAppliedRotation] = useState(0);
            const [isApplyingRotation, setIsApplyingRotation] = useState(false);
            const [previewVersion, setPreviewVersion] = useState(0);

            // Load initial params from server
            useEffect(() => {
                fetch(`${API_BASE}/params`)
                    .then(res => res.json())
                    .then(data => setParams(prev => ({ ...prev, ...data })))
                    .catch(err => console.error('Failed to load params:', err));
            }, []);

            // Update server params when local params change
            const updateParams = useCallback(async (newParams) => {
                try {
                    await fetch(`${API_BASE}/params`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(newParams)
                    });
                } catch (err) {
                    console.error('Failed to update params:', err);
                }
            }, []);

            // Debounce timer ref
            const debounceTimer = React.useRef(null);

            const handleParamChange = (name, value) => {
                const newParams = { ...params, [name]: value };
                setParams(newParams);
                updateParams(newParams);

                // Clear existing timer
                if (debounceTimer.current) {
                    clearTimeout(debounceTimer.current);
                }

                // Auto-refresh reference preview for binarization and morphology params
                const refParams = ['threshold_method', 'manual_threshold', 'adaptive_block_size',
                    'adaptive_c', 'morph_enabled', 'morph_operation', 'morph_kernel_size',
                    'morph_iterations', 'roi_enabled', 'roi_margin'];

                if (hasReference && refParams.includes(name)) {
                    debounceTimer.current = setTimeout(() => refreshReferencePreview(), 300);
                }

                // Auto-rerun detection if test image exists
                if (testImageFile && hasReference) {
                    debounceTimer.current = setTimeout(() => rerunDetection(), 500);
                }
            };

            const refreshReferencePreview = async () => {
                // Don't refresh if we're applying rotation
                if (isApplyingRotation) {
                    console.log('Skipping refresh - rotation in progress');
                    return;
                }

                console.log('refreshReferencePreview called');

                try {
                    const res = await fetch(`${API_BASE}/reference/preview`);
                    const data = await res.json();
                    if (data.status === 'success') {
                        console.log('Preview refreshed from server, first 50 chars:', data.binary.substring(0, 50));
                        setReferencePreview(data.binary);
                        setReferenceInfo(data.info);
                        setPreviewVersion(v => v + 1);
                    }
                } catch (err) {
                    console.error('Failed to refresh preview:', err);
                }
            };

            const applyReferenceRotation = async () => {
                if (!hasReference || referenceRotation === appliedRotation) return;

                setIsApplyingRotation(true);
                setLoading(true);

                // IMPORTANT: CSS rotates opposite direction from OpenCV
                // CSS: positive = clockwise, OpenCV: positive = counter-clockwise
                // So we need to negate the angle to match the preview
                const angleToApply = -referenceRotation;

                console.log(`User rotated to: ${referenceRotation}°, sending to backend: ${angleToApply}°`);

                try {
                    const res = await fetch(`${API_BASE}/reference/rotate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ angle: angleToApply })
                    });
                    const data = await res.json();

                    console.log('Rotation response:', {
                        status: data.status,
                        angle: data.angle,
                        hasBinary: !!data.binary,
                        binaryLength: data.binary?.length
                    });

                    if (data.status === 'success') {
                        console.log('Setting rotated preview, first 50 chars:', data.binary.substring(0, 50));

                        // First, reset rotation to 0
                        setReferenceRotation(0);
                        setAppliedRotation(0);

                        // Force update the preview (which is already rotated by backend)
                        // Use functional update to ensure React sees it as a change
                        setReferencePreview(() => data.binary);
                        setReferenceInfo(() => data.info);
                        setPreviewVersion(v => v + 1);

                        console.log('Applied rotation successfully, slider reset to 0, preview updated');

                        // Re-run detection if test exists
                        if (testImageFile) {
                            await rerunDetection();
                        }
                    } else {
                        setError(data.error);
                    }
                } catch (err) {
                    setError('Failed to rotate reference image');
                    console.error('Rotation error:', err);
                }

                setLoading(false);
                setIsApplyingRotation(false);
            };

            const uploadReference = async (file) => {
                setError(null);
                setLoading(true);
                const formData = new FormData();
                formData.append('file', file);

                try {
                    const res = await fetch(`${API_BASE}/reference`, {
                        method: 'POST',
                        body: formData
                    });
                    const data = await res.json();

                    console.log('Reference upload response:', data);

                    if (data.status === 'success') {
                        setReferencePreview(data.preview);
                        setReferenceInfo(data.info);
                        setHasReference(true);
                        setReferenceRotation(0);
                        setAppliedRotation(0);
                        // Clear test results when new reference is uploaded
                        setTestPreview(null);
                        setTestImageFile(null);
                        setResult(null);
                        setResultImages(null);
                        console.log('Reference uploaded successfully');
                    } else {
                        setError(data.error);
                    }
                } catch (err) {
                    setError('Failed to upload reference image');
                    console.error('Upload error:', err);
                }
                setLoading(false);
            };

            const uploadTest = async (file) => {
                if (!hasReference) {
                    setError('Please upload a reference image first');
                    return;
                }

                setError(null);
                setLoading(true);

                // Store the file for rerun detection
                setTestImageFile(file);

                const formData = new FormData();
                formData.append('file', file);

                try {
                    const res = await fetch(`${API_BASE}/detect`, {
                        method: 'POST',
                        body: formData
                    });
                    const data = await res.json();

                    if (data.status === 'success') {
                        setResult(data.result);
                        setResultImages(data.images);
                        setTestPreview(data.images.test_binary);
                    } else {
                        setError(data.error);
                    }
                } catch (err) {
                    setError('Failed to run detection');
                }

                setLoading(false);
            };

            const rerunDetection = async () => {
                if (!testImageFile || !hasReference) return;

                setLoading(true);
                try {
                    const formData = new FormData();
                    formData.append('file', testImageFile);

                    const res = await fetch(`${API_BASE}/detect`, {
                        method: 'POST',
                        body: formData
                    });
                    const data = await res.json();

                    if (data.status === 'success') {
                        setResult(data.result);
                        setResultImages(data.images);
                        setTestPreview(data.images.test_binary);
                    }
                } catch (err) {
                    console.error('Failed to rerun detection:', err);
                }
                setLoading(false);
            };

            const resetParams = async () => {
                try {
                    const res = await fetch(`${API_BASE}/params/reset`, { method: 'POST' });
                    const data = await res.json();
                    if (data.status === 'success') {
                        setParams(data.params);
                        if (hasReference) refreshReferencePreview();
                        if (testImageFile) rerunDetection();
                    }
                } catch (err) {
                    setError('Failed to reset parameters');
                }
            };

            return (
                <div className="container mx-auto px-4 py-6" style={{maxWidth: '1800px'}}>
                    {/* Header */}
                    <header className="text-center mb-4">
                        <h1 className="text-3xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-purple-600 to-pink-600">
                            Flash Detector
                        </h1>
                        <p className="text-gray-600 mt-1">Industrial Vision Inspection System</p>
                    </header>

                    {/* Error Display */}
                    {error && (
                        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
                            {error}
                            <button onClick={() => setError(null)} className="float-right font-bold">&times;</button>
                        </div>
                    )}

                    {/* Main Layout */}
                    <div className="main-layout">
                        {/* Left Panel - Parameters */}
                        <div className="params-panel">
                            <div className="card rounded-lg p-4 h-full">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-xl font-semibold text-purple-600">Parameters</h2>
                                    <button
                                        onClick={resetParams}
                                        className="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 px-2 py-1 rounded"
                                    >
                                        Reset
                                    </button>
                                </div>

                                <div className="space-y-1 max-h-[70vh] overflow-y-auto pr-2">
                                    {/* Binarization Section */}
                                    <h3 className="text-sm font-medium text-gray-700 mb-2 mt-4 border-b border-gray-300 pb-1">
                                        Binarization
                                    </h3>
                                    {['threshold_method', 'manual_threshold', 'adaptive_block_size', 'adaptive_c'].map(name => (
                                        <ParamControl
                                            key={name}
                                            name={name}
                                            config={PARAM_CONFIG[name]}
                                            value={params[name]}
                                            onChange={handleParamChange}
                                            params={params}
                                        />
                                    ))}

                                    {/* Morphology Section */}
                                    <h3 className="text-sm font-medium text-gray-700 mb-2 mt-4 border-b border-gray-300 pb-1">
                                        Morphology
                                    </h3>
                                    {['morph_enabled', 'morph_operation', 'morph_kernel_size', 'morph_iterations'].map(name => (
                                        <ParamControl
                                            key={name}
                                            name={name}
                                            config={PARAM_CONFIG[name]}
                                            value={params[name]}
                                            onChange={handleParamChange}
                                            params={params}
                                        />
                                    ))}

                                    {/* ROI Section */}
                                    <h3 className="text-sm font-medium text-gray-700 mb-2 mt-4 border-b border-gray-300 pb-1">
                                        Region of Interest
                                    </h3>
                                    {['roi_enabled', 'roi_margin'].map(name => (
                                        <ParamControl
                                            key={name}
                                            name={name}
                                            config={PARAM_CONFIG[name]}
                                            value={params[name]}
                                            onChange={handleParamChange}
                                            params={params}
                                        />
                                    ))}

                                    {/* Detection Section */}
                                    <h3 className="text-sm font-medium text-gray-700 mb-2 mt-4 border-b border-gray-300 pb-1">
                                        Detection
                                    </h3>
                                    {['use_reference_threshold', 'min_flash_area', 'alignment_method', 'ransac_threshold'].map(name => (
                                        <ParamControl
                                            key={name}
                                            name={name}
                                            config={PARAM_CONFIG[name]}
                                            value={params[name]}
                                            onChange={handleParamChange}
                                            params={params}
                                        />
                                    ))}
                                </div>

                                {/* Reference Info */}
                                {referenceInfo && (
                                    <div className="mt-4 p-3 bg-gray-100 rounded text-xs border border-gray-200">
                                        <div className="text-gray-600">Threshold: <span className="text-gray-900 font-medium">{referenceInfo.threshold}</span></div>
                                        <div className="text-gray-600">ROI Center: <span className="text-gray-900 font-medium">{referenceInfo.roi_center?.join(', ')}</span></div>
                                        <div className="text-gray-600">ROI Radius: <span className="text-gray-900 font-medium">{referenceInfo.roi_radius}px</span></div>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* Top Right - Images Side by Side */}
                        <div className="images-panel">
                            <ImageDisplay
                                label="Reference Image (Golden Sample)"
                                imageSrc={referencePreview}
                                onUpload={uploadReference}
                                uploadLabel="Upload Reference"
                                showRotationControls={true}
                                rotation={referenceRotation}
                                onRotationChange={setReferenceRotation}
                                onRotationApply={applyReferenceRotation}
                            />
                            <ImageDisplay
                                label="Test Image (To Inspect)"
                                imageSrc={testPreview}
                                onUpload={uploadTest}
                                uploadLabel="Upload Test"
                            />
                        </div>

                        {/* Bottom Right - Results */}
                        <div className="results-panel">
                            {loading && (
                                <div className="flex justify-center items-center py-8">
                                    <div className="loading-spinner mr-3"></div>
                                    <span className="text-gray-600">Processing...</span>
                                </div>
                            )}

                            {result ? (
                                <ResultsDisplay result={result} images={resultImages} />
                            ) : !hasReference ? (
                                <div className="card rounded-lg p-6 text-center">
                                    <h3 className="text-lg font-semibold mb-4 text-purple-600">Getting Started</h3>
                                    <ol className="text-left text-gray-600 space-y-2 max-w-md mx-auto">
                                        <li>1. Upload a <strong className="text-gray-900">Reference Image</strong> (golden sample without defects)</li>
                                        <li>2. Adjust <strong className="text-gray-900">Parameters</strong> on the left to optimize binarization</li>
                                        <li>3. Upload a <strong className="text-gray-900">Test Image</strong> to inspect for flash defects</li>
                                        <li>4. View results in real-time as you adjust parameters</li>
                                    </ol>
                                </div>
                            ) : null}
                        </div>
                    </div>

                    {/* Footer */}
                    <footer className="text-center text-gray-500 text-sm mt-4 pb-4">
                        Flash Detector v1.0 | Solomon-3D Vision Systems
                    </footer>
                </div>
            );
        }

        // Render the app
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
